# 2.1 进程

伪并行：1s内cpu在不同进程之间反复横跳，达成看似在并行执行的错觉

多处理器系统：真正的并行处理，两个或多个CPU共享内存，共同执行

## 2.1.1 进程模型

一个进程就是一个正在执行程序的实例。

前面提到的快速的切换被称为**多道程序设计**

一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程服务。

两个相同的程序是两个进程

## 2.1.2 进程的创建

4种主要的事件会导致创建进程：

1. 系统初始化
2. 正在运行的程序执行了创建进程的系统调用
3. 用户请求创建一个新进程
4. 一个批处理作业的初始化

停留在后台的处理活动的进程称之为**守护进程(daemon)**

四种事件都是基于一个已存在的线程执行一个用于创建进程的系统调用创建的

UNIX系统中，`fork`调用来创建新进程，再使用`execve`来更改其内存运行新的程序。可写的内存不能被共享。通常通过**写时复制(copy-on-write)**机制修改内存。

## 2.1.3 进程的终止

终止条件：

1. 正常退出
2. 出错退出
3. 严重错误
4. 被其他应用杀死

第二个是外部的错误，自愿退出，例如缺少文件等。第三个是程序内部的错误，非自愿推出，例如算法出现错误。

## 2.1.4 进程的层次结构

进程只能由一个父进程，但是可以由很多子进程

UNIX中是一棵进程树

Windows下所有进程地位相同

## 2.1.5 进程的状态

进程在逻辑上不能运行的时候进入阻塞的状态。例如等待输入。

三种状态：

1. 运行态
2. 就绪态
3. 阻塞态

<img src="%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.assets/image-20210110193425019.png" alt="image-20210110193425019" style="zoom:67%;" />



1是程序发现不能进行下去，4是程序觉得自己行了的时候

2，3是CPU调度

## 2.1.6 进程的实现

为了实现进程模型，操作系统会维护一张**进程表(process table)**.

与每个I/O类关联的是**中断向量(interrupt vector)**的位置。包含中断服务程序的入口地址。

所有的终端都从保存寄存器开始

## 2.1.7 多道程序模型

等待I/O的时候CPU空转

CPU利用率 = $1-p^n$

p是一个进程等待I/O操作的时间和它停留在内存中时间的比值

# 2.2 线程

进程 = 地址空间 + 控制线程

## 2.2.1 线程的使用

线程的使用是为了： 1. 并行的实体拥有共享同一个地址空间和所有可用数据的能力2. 线程比进程切换速度更快更轻量

例如

Word 在处理一个大文档时候。假设文档有800页，前台只需要显示一页。如果用户在第一页删除一行，那么这时候逻辑上后面都已经做出修改了。但是如果只有一个线程在前台交互+计算，那么如果用户跳转到600页的时候，这个线程需要首先对前600页进行统一的处理，从而得出第600页真正的样子。如果有两个线程，那么可以在用户做出修改后，另一个后台默默在后台进行处理，如果要跳转，这时候应该已经处理好了，第600页可以直接显示出来。

如果用进程，因为进程不能共享内存区，这时候不能访问同一个文件，所以需要用到线程。

**多线程依靠并行性，阻塞系统调用来改进单线程进程以及有限状态机。**

输入线程把数据读入到输入缓冲区中，

处理线程把数据从输入缓冲区中取出来，把结果放到输出缓冲区中，

输出线程把数据从输出缓冲区中读出。

要求操作系统只阻塞线程而不阻塞进程

## 2.2.2 经典的线程模型

进程模型基于两种独立的概念：资源分组处理和执行。

进程的一个角度是：一个程序的所有资源的打包体。线程是为了完成一个共同的工作创立的，所以可以分享资源，线程之间没有保护。一个线程可以对另一个线程做任何事^

在同一个进程中可以并行运行很多线程，且多个线程共享一个地址空间和其他资源。

每个线程有自己的堆栈，因为通常线程处理的是不同的过程，堆栈中会存放返回地址

一般是通过创建一个线程，线程再创建另一个线程。线程间并不像进程之间有父子关系，这是完全平等的。

## 2.2.3 POSIX线程

```c
#include<pthread.h>
#include<stdio.h>
#include<stdlib.h>
#define NUMBER_OF_THREADS 10
void *print_hello_world(void *tid)
{
	printf("Hello World!!%d\n",tid);//输出tid
	pthread_exit(NULL);//推出线程
}

int main(){
	pthread_t threads[NUMBER_OF_THREADS];//创建线程数组
	int status , i;
	for(i = 0 ; i < NUMBER_OF_THREADS;i++){
		printf("I'm Main,Creating thread %d\n",i);
		status = pthread_create(&threads[i],NULL,print_hello_world,(void*)i);//创建线程，运行print_hello_world
		if(status!=0){
			printf("Oops, pthread_create returned an error code %d\n",status);
			exit(-1);	
		}
	}
	exit(NULL);
}
//运行时 gcc -pthread 开关
```



















